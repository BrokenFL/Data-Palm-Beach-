# -*- coding: utf-8 -*-
"""CleanandProcess

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZPjjwZg_RIe_9xkHS4RbW5R8LU_aaxbi
"""

import pandas as pd
import numpy as np

data_dictionary = {
    'listing_number': 'str',
    'cumulative_dom': 'int',
    'days_on_market': 'int',
    'short_address': 'str',
    'baths_full': 'int',
    'baths_half': 'int (default to 0 if no input)',
    'cancel_date': 'datetime (NA if not canceled)',
    'listing_date': 'datetime',
    'list_price': 'float',
    'front_exp': 'str (categories)',
    'expiration_date': 'datetime (NA if not expired)',
    'parcel_id': 'int (remove dashes, 17 digits)',
    'sold_date': 'datetime (NA if not sold)',
    'sold_price': 'float (NA if no sold date)',
    'sqft_living': 'int (default to sqft_total if no input)',
    'sqft_total': 'int',
    'under_contract_date': 'datetime (NA if not under contract)',
    'waterfrontage': 'bool',
    'withdrawn_date': 'datetime (NA if not withdrawn)',
    'year_built': 'int',
    'year_roof_installed': 'int (default to year_built if no input)',
    'sqft_guest_house': 'int (default to 0 if no input)',
    'construction_cbs': 'bool',
    'storm_protection_accordion_shutters': 'str (categories)',
    'storm_protection_impact_glass': 'str (categories)',
    'storm_protection_panel_shutters': 'str (categories)',
    'public_remarks': 'str',
    'area': 'str (categories)',
    'temp_off_market_date': 'datetime (NA if not temporary off market)',
    'garage_spaces': 'int (default to 0 if no input)',
    'furnished_furnished': 'bool',
    'subdivision': 'str (normalized to lowercase)',
    'terms_of_sale': 'str (categories)',
    'zip_code': 'str (categories)',
    'city': 'str (categories)',
    'guest_house': 'bool',
    'high_school': 'str (categories)',
    'homeowners_assoc': 'bool',
    'lot_sqft': 'int (default to 0 if no input)',
    'private_pool': 'bool',
    'sold_price_sqft': 'float (default to 0 if no sold price)',
    'legal_desc': 'str',
    'spa': 'bool',
    'state_province': 'str (categories)',
    'street_number': 'int',
    'tax_year': 'int',
    'taxes': 'float',
    'total_bedrooms': 'int',
    'total_floors_stories': 'int (default to 1 if no input)',
    'total_units_in_bldg': 'int (only applicable to condominiums)',
    'ttl_units_in_complex': 'int (to be ignored)',
    'original_list_price': 'float',
    'development_name': 'str',
    'unit_floor_number': 'int (only applicable to condominiums)',
    'unit_number': 'str (remove blank spaces)',
    'type': 'str (categories)',
    'geo_area': 'int (categories)',
    'geo_lat': 'float',
    'geo_lon': 'float',
    'hoa_poa_coa_monthly': 'float (NA if no HOA)',
    'special_assessment': 'bool',
    'parcel_subdivision': 'str',
    'event_date': 'datetime',
    'end_of_listing_date': 'datetime'
}

# Replace the path with the actual path of your CSV file
file_path = '/mnt/data/customexport (19).csv'

# Load the dataset with ISO-8859-1 encoding
df = pd.read_csv(file_path, encoding='ISO-8859-1')

# Normalize column names based on the specified rules
df.columns = (
    df.columns
    .str.replace(' ', '_')
    .str.replace('-', '_')
    .str.replace('/', '_')
    .str.replace('#', 'number')
    .str.replace(':', '')
    .str.replace('(', '')
    .str.replace(')', '')
    .str.replace('___', '_')
    .str.replace('__', '_')
    .str.rstrip('_')
    .str.lower()
)

# Display the new headers to confirm changes
print(df.columns)

def assign_data_types(df):
    # Handling specific conversions and defaults as per manual instructions
    for column, dtype in data_dictionary.items():
        if 'datetime' in dtype:
            df[column] = pd.to_datetime(df[column], errors='coerce')  # Convert to datetime, NA for invalid entries
        elif dtype == 'str':
            df[column] = df[column].astype(str)
        elif dtype == 'int':
            # Default to 0 if no input, except for specific fields handled individually below
            df[column] = pd.to_numeric(df[column], errors='coerce').fillna(0).astype(int)
        elif dtype == 'float':
            # Convert to float, NA for invalid entries; specific fields like 'sold_price' handled below
            df[column] = pd.to_numeric(df[column], errors='coerce')
        elif dtype == 'bool':
            # Boolean conversion will be handled separately due to the variety of input formats
            pass

def process_data(df, data_dictionary):
    # Handle booleans
    df = handle_booleans(df, data_dictionary)
    # Handle datetimes
    df = handle_datetimes(df, data_dictionary)
    # Handle strings values
    df = process_string_fields(df, data_dictionary)
    # Handle missing values (integers, floats, etc.)
    df = handle_missing_values(df, data_dictionary)
    # Create new columns
    df = add_additional_columns(df)
    return df

def handle_booleans(df, data_dictionary):
    boolean_columns = {
        'waterfront': {'true_values': ['Yes'], 'false_values': ['No']},
        'construction_cbs': {'true_values': ['Yes'], 'false_values': ['No']},
        'furnished_furnished': {'true_values': ['Yes'], 'false_values': ['No']},
        'guest_house': {'true_values': ['Yes'], 'false_values': ['No']},
        'homeowners_assoc': {'true_values': ['M'], 'false_values': ['N']},
        'private_pool': {'true_values': ['Yes'], 'false_values': ['No']},
        'spa': {'true_values': ['Yes'], 'false_values': ['No']},
        'special_assessment': {'true_values': ['Y'], 'false_values': ['N']}
    }

    def convert_to_boolean(df, column, true_values, false_values):
        df[column] = df[column].apply(lambda x: True if x in true_values else False if x in false_values else pd.NA)
        return df

    for column, params in boolean_columns.items():
        df = convert_to_boolean(df, column, params['true_values'], params['false_values'])
    return df

def handle_datetimes(df, data_dictionary):
    datetime_fields = ['cancel_date', 'listing_date', 'expiration_date', 'sold_date', 'under_contract_date', 'withdrawn_date',  'temp_off_market_date']
    for field in datetime_fields:
        df[field] = pd.to_datetime(df[field], errors='coerce')
    return df

def process_string_fields(df, data_dictionary):
    for col, field_type in data_dictionary.items():
        if field_type == 'str':  # For basic string fields
            df[col] = clean_text_column(df[col])
        elif 'categories)' in field_type:  # Check for your specific marker
            df[col] = build_categories_for_column(df[col])
    return df

    def build_categories_for_column(column):
        unique_values = column.dropna().unique()
        categories = [val.lower() for val in unique_values]  # Lowercase normalization
        return column.fillna('NA').map(lambda x: x.lower() if x in categories else x)

    def clean_text_column(column):
        return column.str.lower()  # Basic lowercase transformation

def handle_missing_values(df, data_dictionary):
    # 1. HOA/POA/COA Monthly (hoa_poa_coa_monthly):
    # Treated as a float. If homeowners_assoc is False, the value is set to 0.
    df.loc[~df['homeowners_assoc'], 'hoa_poa_coa_monthly'] = 0
    # 2. List Price (list_price):
    # Always treated as a float. Filled with 0 if missing.
    df['list_price'] = pd.to_numeric(df['list_price'], errors='coerce').fillna(0)
    # 3. Sold Price (sold_price):
    df['sold_price'] = pd.to_numeric(df['sold_price'], errors='coerce')
    df.loc[df['sold_date'].isna(), 'sold_price'] = np.nan
    # 4. Sold Price Per Square Foot (sold_price_sqft):
    # Calculated as a float. Set to 0 if not sold.
    df['sold_price_sqft'] = df.apply(lambda x: x['sold_price'] / x['sqft_total'] if x['sold_price'] > 0 else 0, axis=1)
    # 5. Geo Latitude (geo_lat) and Geo Longitude (geo_lon):
    # Treated as floats. Represent geographical coordinates.
    df['geo_lat'] = pd.to_numeric(df['geo_lat'], errors='coerce').fillna(0)
    df['geo_lon'] = pd.to_numeric(df['geo_lon'], errors='coerce').fillna(0)
    # 6. Taxes:
    # Treated as a float. Represents annual property taxes. Set to 0 if missing or invalid.
    df['taxes'] = pd.to_numeric(df['taxes'], errors='coerce').fillna(0)
    # HOA/POA/COA Monthly fees
    df['hoa_poa_coa_monthly'] = pd.to_numeric(df['hoa_poa_coa_monthly'], errors='coerce').fillna(0)
    # Rule 1: Cumulative DOM / Days on Market
    df['cumulative_dom'] = df.apply(lambda row: row['days_on_market'] if pd.isna(row['cumulative_dom']) else row['cumulative_dom'], axis=1)
    # Rule 2: Baths (Default to 0)
    df['baths_half'] = df['baths_half'].fillna(0)
    # Rule 3: Parcel ID (Cleaning and Limiting Length)
    df['parcel_id'] = df['parcel_id'].str.replace('-', '').astype(str).str.slice(0, 17)
    # Rule 4: sqft_living / sqft_total Relationship
    df['sold_price_sqft'] = df.apply( lambda x: x['sold_price'] / x['sqft_total'] if pd.notna(x['sold_date']) else np.nan, axis=1)
    # Rule 5: year_roof_installed (Default to year_built)
    df['year_roof_installed'] = df['year_roof_installed'].fillna(df['year_built'])
    # Rule 6: Other Defaults (garage_spaces, lot_sqft, sqft_guest_house)
    df['garage_spaces'] = df['garage_spaces'].fillna(0)
    df['lot_sqft'] = df['lot_sqft'].fillna(0)
    df['sqft_guest_house'] = df['sqft_guest_house'].fillna(0)
    df['total_floors_stories'] = df['total_floors_stories'].fillna(1)
    # Rule 7: Conditional Filling (total_units_in_bldg, unit_floor_number)
    df.loc[df['type'] == 'CD', 'total_units_in_bldg'] = df['total_units_in_bldg'].fillna(np.nan)
    df.loc[df['type'] == 'CD', 'unit_floor_number'] = df['unit_floor_number'].fillna(np.nan)
    return df

def add_additional_columns(df):
    # 1. "parcel_subdivision"
    df['parcel_subdivision'] = df['parcel_id'].str[:10]
    # 2. "event_date"
    event_date_columns = ['sold_date', 'cancel_date', 'withdrawn_date', 'expiration_date', 'temp_off_market_date']
    df['event_date'] = pd.NaT
    for col in event_date_columns:
        df['event_date'] = df['event_date'].fillna(df[col])
    # 3. "end_of_listing_date"
    df['cumulative_dom'] = pd.to_numeric(df['cumulative_dom'], errors='coerce').fillna(0)
    df['end_of_listing_date'] = pd.NaT
    # Apply conditions and format dates
    df.loc[df['event_date'].notna(), 'end_of_listing_date'] = df['event_date'].dt.strftime('%Y-%m-%d')
    df.loc[df['event_date'].isna(), 'end_of_listing_date'] = (df['listing_date'] + pd.to_timedelta(df['cumulative_dom'], unit='D')).dt.strftime('%Y-%m-%d')
    return df

if __name__ == "__main__":
    filepath = 'path_to_your_real_estate_data.csv'
    df = pd.read_csv(filepath, encoding='ISO-8859-1')
    df = assign_data_types(df, data_dictionary)
    df = handle_booleans(df, data_dictionary)
    df = handle_datetimes(df, data_dictionary)
    df = process_string_fields(df, data_dictionary)
    df = handle_missing_values(df, data_dictionary)
    df = add_additional_columns(df)
    df.to_csv('cleaned_real_estate_data.csv', index=False)